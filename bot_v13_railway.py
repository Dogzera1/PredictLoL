#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
BOT LOL V3 ULTRA AVAN√áADO - Sistema de Tips Profissional
Sistema de unidades padr√£o de grupos de apostas profissionais
APENAS DADOS REAIS DA API DA RIOT GAMES
"""

import os
import sys
import time
import asyncio
import logging
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import json
import pytz

# Flask para health check
from flask import Flask, jsonify
import requests

# Detectar vers√£o do python-telegram-bot
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
    from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
    from telegram.error import TelegramError
    from telegram.constants import ParseMode
    TELEGRAM_VERSION = "v20+"
    logger = logging.getLogger(__name__)
    logger.info("üîç Detectada vers√£o python-telegram-bot v20+")
except ImportError:
    try:
        from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ParseMode
        from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, CallbackContext
        from telegram.error import TelegramError
        TELEGRAM_VERSION = "v13"
        logger = logging.getLogger(__name__)
        logger.info("üîç Detectada vers√£o python-telegram-bot v13")
    except ImportError as e:
        print(f"‚ùå Erro ao importar python-telegram-bot: {e}")
        exit(1)

import numpy as np
import aiohttp

# Configura√ß√µes
TOKEN = os.getenv('TELEGRAM_TOKEN', '7584060058:AAFTZcmirun47zLiCCm48Trre6c3oXnM-Cg')
OWNER_ID = int(os.getenv('OWNER_ID', '6404423764'))
PORT = int(os.getenv('PORT', 5000))

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Flask app para healthcheck
app = Flask(__name__)

@app.route('/health')
def health_check():
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'service': 'bot_lol_v3_professional_units',
        'version': TELEGRAM_VERSION,
        'units_system': 'PROFESSIONAL_STANDARD'
    })

@app.route('/')
def root():
    return jsonify({
        'message': 'BOT LOL V3 - Sistema de Unidades Profissional',
        'status': 'online',
        'units_system': 'Padr√£o de grupos profissionais'
    })

class ProfessionalUnitsSystem:
    """Sistema de Unidades Padr√£o de Grupos Profissionais"""
    
    def __init__(self, bankroll: float = 1000.0):
        self.bankroll = bankroll
        self.base_unit = bankroll * 0.01  # 1% do bankroll = 1 unidade base
        
        # Sistema de unidades padr√£o de grupos profissionais
        self.unit_scale = {
            # Baseado em confian√ßa e EV
            'max_confidence_high_ev': 5.0,    # 90%+ confian√ßa, 15%+ EV
            'high_confidence_high_ev': 4.0,   # 85%+ confian√ßa, 12%+ EV  
            'high_confidence_good_ev': 3.0,   # 80%+ confian√ßa, 10%+ EV
            'good_confidence_good_ev': 2.5,   # 75%+ confian√ßa, 8%+ EV
            'medium_confidence': 2.0,         # 70%+ confian√ßa, 6%+ EV
            'low_confidence': 1.0,            # 65%+ confian√ßa, 5%+ EV
            'minimum': 0.5                    # M√≠nimo absoluto
        }
        
        # Hist√≥rico
        self.bet_history = []
        self.performance_stats = {
            'total_bets': 0,
            'wins': 0,
            'losses': 0,
            'total_units_staked': 0,
            'total_units_profit': 0,
            'roi_percentage': 0,
            'strike_rate': 0
        }
        
        logger.info(f"üí∞ Sistema de Unidades Profissional inicializado - Bankroll: ${bankroll}")
    
    def calculate_units(self, confidence: float, ev_percentage: float, 
                       league_tier: str = "tier2") -> Dict:
        """Calcula unidades usando sistema padr√£o de grupos profissionais"""
        
        # Ajuste por tier da liga
        tier_multipliers = {
            'tier1': 1.0,    # LCK, LPL, LEC, LCS
            'tier2': 0.9,    # Ligas regionais principais
            'tier3': 0.8     # Ligas menores
        }
        
        tier_mult = tier_multipliers.get(league_tier, 0.8)
        
        # Determinar unidades baseado em confian√ßa e EV
        if confidence >= 90 and ev_percentage >= 15:
            base_units = self.unit_scale['max_confidence_high_ev']
            risk_level = "Muito Alto"
        elif confidence >= 85 and ev_percentage >= 12:
            base_units = self.unit_scale['high_confidence_high_ev']
            risk_level = "Alto"
        elif confidence >= 80 and ev_percentage >= 10:
            base_units = self.unit_scale['high_confidence_good_ev']
            risk_level = "Alto"
        elif confidence >= 75 and ev_percentage >= 8:
            base_units = self.unit_scale['good_confidence_good_ev']
            risk_level = "M√©dio-Alto"
        elif confidence >= 70 and ev_percentage >= 6:
            base_units = self.unit_scale['medium_confidence']
            risk_level = "M√©dio"
        elif confidence >= 65 and ev_percentage >= 5:
            base_units = self.unit_scale['low_confidence']
            risk_level = "Baixo"
        else:
            # N√£o apostar se n√£o atender crit√©rios m√≠nimos
            return {
                'units': 0,
                'stake_amount': 0,
                'risk_level': 'Sem Valor',
                'recommendation': 'N√ÉO APOSTAR - Crit√©rios n√£o atendidos',
                'reason': f'Confian√ßa: {confidence:.1f}% | EV: {ev_percentage:.1f}%'
            }
        
        # Aplicar multiplicador de tier
        final_units = base_units * tier_mult
        
        # Calcular valor da aposta
        stake_amount = final_units * self.base_unit
        
        # Ajuste fino baseado em EV excepcional
        if ev_percentage >= 20:
            final_units *= 1.2  # Bonus 20% para EV excepcional
            risk_level = "M√°ximo"
        elif ev_percentage >= 18:
            final_units *= 1.1  # Bonus 10% para EV muito alto
        
        # Limites de seguran√ßa
        final_units = min(final_units, 5.0)  # M√°ximo 5 unidades
        final_units = max(final_units, 0.5)  # M√≠nimo 0.5 unidades
        
        stake_amount = final_units * self.base_unit
        
        return {
            'units': round(final_units, 1),
            'stake_amount': round(stake_amount, 2),
            'risk_level': risk_level,
            'tier_multiplier': tier_mult,
            'confidence': confidence,
            'ev_percentage': ev_percentage,
            'recommendation': f"Apostar {final_units:.1f} unidades (${stake_amount:.2f})",
            'reasoning': self._get_units_reasoning(confidence, ev_percentage, league_tier)
        }
    
    def _get_units_reasoning(self, confidence: float, ev_percentage: float, 
                           league_tier: str) -> str:
        """Gera explica√ß√£o do c√°lculo de unidades"""
        
        reasoning_parts = []
        
        # Explicar base da decis√£o
        if confidence >= 85 and ev_percentage >= 12:
            reasoning_parts.append("üî• Alta confian√ßa + Excelente valor")
        elif confidence >= 80 and ev_percentage >= 10:
            reasoning_parts.append("‚≠ê Boa confian√ßa + Bom valor")
        elif confidence >= 75 and ev_percentage >= 8:
            reasoning_parts.append("‚úÖ Confian√ßa adequada + Valor positivo")
        else:
            reasoning_parts.append("‚ö†Ô∏è Crit√©rios m√≠nimos atendidos")
        
        # Explicar ajuste por liga
        if league_tier == 'tier1':
            reasoning_parts.append("üèÜ Liga Tier 1 (sem redu√ß√£o)")
        elif league_tier == 'tier2':
            reasoning_parts.append("ü•à Liga Tier 2 (-10%)")
        else:
            reasoning_parts.append("ü•â Liga menor (-20%)")
        
        # Bonus por EV excepcional
        if ev_percentage >= 20:
            reasoning_parts.append("üíé Bonus +20% por EV excepcional")
        elif ev_percentage >= 18:
            reasoning_parts.append("üí∞ Bonus +10% por EV muito alto")
        
        return " ‚Ä¢ ".join(reasoning_parts)

class RiotAPIClient:
    """Cliente para API da Riot Games - APENAS DADOS REAIS"""
    
    def __init__(self):
        self.api_key = "0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z"
        self.base_urls = {
            'esports': 'https://esports-api.lolesports.com/persisted/gw',
            'prod': 'https://prod-relapi.ewp.gg/persisted/gw'
        }
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
            'x-api-key': self.api_key
        }
        logger.info("üîó RiotAPIClient inicializado - APENAS DADOS REAIS")
    
    async def get_live_matches(self) -> List[Dict]:
        """Busca partidas ao vivo REAIS da API oficial"""
        logger.info("üîç Buscando partidas ao vivo...")
        
        endpoints = [
            f"{self.base_urls['esports']}/getLive?hl=pt-BR",
            f"{self.base_urls['esports']}/getSchedule?hl=pt-BR"
        ]
        
        all_matches = []
        
        for endpoint in endpoints:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(endpoint, headers=self.headers, timeout=10) as response:
                        if response.status == 200:
                            data = await response.json()
                            matches = self._extract_matches(data)
                            all_matches.extend(matches)
            except Exception as e:
                logger.warning(f"‚ùå Erro no endpoint: {e}")
                continue
        
        return all_matches[:10]  # M√°ximo 10 partidas

class ProfessionalTipsSystem:
    """Sistema de Tips Profissional com Unidades Padr√£o"""
    
    def __init__(self, riot_client=None):
        self.riot_client = riot_client or RiotAPIClient()
        self.units_system = ProfessionalUnitsSystem()
        self.tips_database = []
        self.given_tips = set()
        
        # Crit√©rios profissionais
        self.min_ev_percentage = 8.0
        self.min_confidence_score = 75.0
        self.max_tips_per_week = 5
        
        logger.info("üéØ Sistema de Tips Profissional inicializado")

class LoLBotV3UltraAdvanced:
    """Bot LoL V3 Ultra Avan√ßado com Sistema de Unidades Profissional"""
    
    def __init__(self):
        self.riot_client = RiotAPIClient()
        self.tips_system = ProfessionalTipsSystem(self.riot_client)
        self.live_matches_cache = {}
        self.cache_timestamp = None
        
        logger.info("ü§ñ Bot LoL V3 Ultra Avan√ßado inicializado")
    
    async def start_command(self, update: Update, context) -> None:
        """Comando /start"""
        user = update.effective_user
        welcome_message = f"""
üéÆ **BOT LOL V3 ULTRA AVAN√áADO** üéÆ

Ol√° {user.first_name}! üëã

üé≤ **SISTEMA DE UNIDADES PROFISSIONAL**
üìä Baseado em grupos de apostas profissionais
‚ö° Sem Kelly Criterion - Sistema simplificado
üéØ Crit√©rios: 65%+ confian√ßa, 5%+ EV m√≠nimo

üî• **FUNCIONALIDADES:**
‚Ä¢ üéØ Tips profissionais seletivos
‚Ä¢ üìä Sistema de unidades padr√£o
‚Ä¢ üéÆ Partidas ao vivo selecion√°veis
‚Ä¢ üìà Value betting avan√ßado
‚Ä¢ üìã Estat√≠sticas detalhadas

Use /menu para ver todas as op√ß√µes!
        """
        
        keyboard = [
            [InlineKeyboardButton("üéØ Tips Profissionais", callback_data="tips")],
            [InlineKeyboardButton("üéÆ Partidas Ao Vivo", callback_data="live_matches")],
            [InlineKeyboardButton("üìä Sistema de Unidades", callback_data="units_info")],
            [InlineKeyboardButton("üìà Value Betting", callback_data="value_betting")],
            [InlineKeyboardButton("üìã Menu Completo", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if TELEGRAM_VERSION == "v20+":
            await update.message.reply_text(welcome_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        else:
            await update.message.reply_text(welcome_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    
    async def menu_command(self, update: Update, context) -> None:
        """Comando /menu"""
        menu_message = """
üéÆ **MENU PRINCIPAL - BOT LOL V3** üéÆ

üéØ **TIPS & AN√ÅLISES:**
‚Ä¢ /tips - Tips profissionais
‚Ä¢ /live - Partidas ao vivo
‚Ä¢ /value - Value betting
‚Ä¢ /stats - Estat√≠sticas

üé≤ **SISTEMA DE UNIDADES:**
‚Ä¢ /units - Explica√ß√£o do sistema
‚Ä¢ /performance - Performance atual
‚Ä¢ /history - Hist√≥rico de apostas

üìä **INFORMA√á√ïES:**
‚Ä¢ /help - Ajuda completa
‚Ä¢ /about - Sobre o bot

Clique nos bot√µes abaixo para navega√ß√£o r√°pida:
        """
        
        keyboard = [
            [InlineKeyboardButton("üéØ Tips", callback_data="tips"), 
             InlineKeyboardButton("üéÆ Ao Vivo", callback_data="live_matches")],
            [InlineKeyboardButton("üìà Value Bets", callback_data="value_betting"), 
             InlineKeyboardButton("üìä Unidades", callback_data="units_info")],
            [InlineKeyboardButton("üìã Stats", callback_data="stats"), 
             InlineKeyboardButton("‚ùì Ajuda", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if TELEGRAM_VERSION == "v20+":
            await update.message.reply_text(menu_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        else:
            await update.message.reply_text(menu_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    
    async def tips_command(self, update: Update, context) -> None:
        """Comando /tips"""
        try:
            tip = await self.tips_system.generate_professional_tip()
            
            if tip:
                tip_message = f"""
üéØ **TIP PROFISSIONAL** üéØ

üèÜ **{tip['title']}**
üéÆ Liga: {tip['league']}

üìä **AN√ÅLISE:**
‚Ä¢ Confian√ßa: {tip['confidence_score']:.1f}%
‚Ä¢ EV: {tip['ev_percentage']:.1f}%
‚Ä¢ Probabilidade: {tip['win_probability']*100:.1f}%

üé≤ **UNIDADES:**
‚Ä¢ Apostar: {tip['units']} unidades
‚Ä¢ Valor: ${tip['stake_amount']:.2f}
‚Ä¢ Risco: {tip['risk_level']}

üí° **Explica√ß√£o:**
{tip['reasoning']}

‚≠ê **Recomenda√ß√£o:** {tip['recommended_team']}
                """
            else:
                tip_message = """
üéØ **NENHUM TIP DISPON√çVEL** üéØ

‚ùå Nenhuma partida atende aos crit√©rios profissionais no momento.

üìã **Crit√©rios m√≠nimos:**
‚Ä¢ Confian√ßa: 75%+
‚Ä¢ EV: 8%+
‚Ä¢ Times conhecidos
‚Ä¢ Liga tier 1 ou 2

üîÑ Tente novamente em alguns minutos.
                """
            
            keyboard = [
                [InlineKeyboardButton("üîÑ Novo Tip", callback_data="tips")],
                [InlineKeyboardButton("üìä Sistema Unidades", callback_data="units_info")],
                [InlineKeyboardButton("üè† Menu", callback_data="main_menu")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if TELEGRAM_VERSION == "v20+":
                await update.message.reply_text(tip_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
            else:
                await update.message.reply_text(tip_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
                
        except Exception as e:
            logger.error(f"Erro no comando tips: {e}")
            error_message = "‚ùå Erro ao gerar tip. Tente novamente."
            if TELEGRAM_VERSION == "v20+":
                await update.message.reply_text(error_message)
            else:
                await update.message.reply_text(error_message)
    
    async def live_matches_command(self, update: Update, context) -> None:
        """Comando /live"""
        try:
            matches = await self.riot_client.get_live_matches()
            
            if matches:
                message = "üéÆ **PARTIDAS AO VIVO** üéÆ\n\nSelecione uma partida para an√°lise detalhada:\n\n"
                
                keyboard = []
                for i, match in enumerate(matches[:8]):  # M√°ximo 8 partidas
                    teams = match.get('teams', [])
                    if len(teams) >= 2:
                        team1 = teams[0].get('name', 'Team1')
                        team2 = teams[1].get('name', 'Team2')
                        league = match.get('league', 'League')
                        
                        button_text = f"{team1} vs {team2}"
                        if len(button_text) > 30:
                            button_text = button_text[:27] + "..."
                        
                        keyboard.append([InlineKeyboardButton(
                            button_text, 
                            callback_data=f"match_{i}"
                        )])
                        
                        # Cache da partida
                        self.live_matches_cache[i] = match
                
                keyboard.append([InlineKeyboardButton("üîÑ Atualizar", callback_data="live_matches")])
                keyboard.append([InlineKeyboardButton("üè† Menu", callback_data="main_menu")])
                
                self.cache_timestamp = datetime.now()
                
            else:
                message = """
üéÆ **NENHUMA PARTIDA AO VIVO** üéÆ

‚ùå N√£o h√° partidas ao vivo no momento.

üîÑ Tente novamente em alguns minutos.
                """
                keyboard = [
                    [InlineKeyboardButton("üîÑ Atualizar", callback_data="live_matches")],
                    [InlineKeyboardButton("üè† Menu", callback_data="main_menu")]
                ]
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if TELEGRAM_VERSION == "v20+":
                await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
            else:
                await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
                
        except Exception as e:
            logger.error(f"Erro no comando live: {e}")
            error_message = "‚ùå Erro ao buscar partidas. Tente novamente."
            if TELEGRAM_VERSION == "v20+":
                await update.message.reply_text(error_message)
            else:
                await update.message.reply_text(error_message)
    
    async def callback_handler(self, update: Update, context) -> None:
        """Handler para callbacks dos bot√µes"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        
        try:
            if data == "tips":
                await self._handle_tips_callback(query)
            elif data == "live_matches":
                await self._handle_live_matches_callback(query)
            elif data == "units_info":
                await self._handle_units_info_callback(query)
            elif data == "value_betting":
                await self._handle_value_betting_callback(query)
            elif data == "main_menu":
                await self._handle_main_menu_callback(query)
            elif data.startswith("match_"):
                match_index = int(data.split("_")[1])
                await self._handle_match_details_callback(query, match_index)
            else:
                await query.edit_message_text("‚ùå Op√ß√£o n√£o reconhecida.")
                
        except Exception as e:
            logger.error(f"Erro no callback handler: {e}")
            await query.edit_message_text("‚ùå Erro interno. Tente novamente.")
    
    async def _handle_units_info_callback(self, query) -> None:
        """Mostra informa√ß√µes do sistema de unidades"""
        units_info = self.tips_system.units_system.get_units_explanation()
        
        keyboard = [
            [InlineKeyboardButton("üéØ Gerar Tip", callback_data="tips")],
            [InlineKeyboardButton("üè† Menu", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(units_info, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

def run_flask_app():
    """Executa Flask em thread separada"""
    app.run(host='0.0.0.0', port=PORT, debug=False)

def main():
    """Fun√ß√£o principal"""
    try:
        logger.info("üéÆ INICIANDO BOT LOL V3 - SISTEMA DE UNIDADES PROFISSIONAL")
        logger.info("=" * 60)
        logger.info("üé≤ Sistema de Unidades: PADR√ÉO DE GRUPOS PROFISSIONAIS")
        logger.info("üìä Baseado em: Confian√ßa + EV + Tier da Liga")
        logger.info("‚ö° Sem Kelly Criterion - Sistema simplificado")
        logger.info("üéØ Crit√©rios: 65%+ confian√ßa, 5%+ EV m√≠nimo")
        logger.info("=" * 60)
        
        # Iniciar Flask
        flask_thread = threading.Thread(target=run_flask_app, daemon=True)
        flask_thread.start()
        logger.info(f"üåê Health check rodando na porta {PORT}")
        
        # Inicializar bot
        bot = LoLBotV3UltraAdvanced()
        
        if TELEGRAM_VERSION == "v20+":
            # Vers√£o v20+
            application = Application.builder().token(TOKEN).build()
            
            # Handlers
            application.add_handler(CommandHandler("start", bot.start_command))
            application.add_handler(CommandHandler("menu", bot.menu_command))
            application.add_handler(CommandHandler("tips", bot.tips_command))
            application.add_handler(CommandHandler("live", bot.live_matches_command))
            application.add_handler(CallbackQueryHandler(bot.callback_handler))
            
            logger.info("‚úÖ Bot configurado (v20+) - Iniciando polling...")
            application.run_polling()
            
        else:
            # Vers√£o v13
            updater = Updater(TOKEN)
            dispatcher = updater.dispatcher
            
            # Handlers
            dispatcher.add_handler(CommandHandler("start", bot.start_command))
            dispatcher.add_handler(CommandHandler("menu", bot.menu_command))
            dispatcher.add_handler(CommandHandler("tips", bot.tips_command))
            dispatcher.add_handler(CommandHandler("live", bot.live_matches_command))
            dispatcher.add_handler(CallbackQueryHandler(bot.callback_handler))
            
            logger.info("‚úÖ Bot configurado (v13) - Iniciando polling...")
            updater.start_polling()
            updater.idle()
                
    except Exception as e:
        logger.error(f"‚ùå Erro: {e}")

if __name__ == "__main__":
    main() 